# Kruskal算法

算法过程：

$(i)$ 选$e_1 \in E(G)$，使得$w(e_1) = \min$ 。
$(ii)$ 若$ e_1, e_2, ..., e_i$已选好，则从$E(G)-\{ e_1, e_2, ..., e_i\}$中选取$e$，使得
①$G[{ e_1, e_2, ..., e_i, e_{i+1}}]$中无圈，且
②$w(e_{i+1}) = \min$ 。
$(iii)$ 直到选得$e_{v-1}$为止。

&emsp;&emsp;此次用$index_{2 * n}$存放各边端点的信息，当选中某一边之后，就将此边对应的顶点序号中较大序号$u$改记为此边的另一序号$v$，同时把后面边中所有序号为$u$的改记为$v $。此方法的几何意义是：将序号$u$的这个顶点收缩到$v$顶点，$u$顶点不复存在。后面继续寻查时，发现某边的两个顶点序号相同时，认为已被收缩掉，失去了被选取的资格。从几何角度看，这个过程是逐步将图中的顶点合并成一个连通的网络：

- 每次选择一条边，将两个顶点合并成一个连通分量。
- 通过合并顶点，避免重复选择已经连接的部分，防止形成环。
- 最终，所有顶点被连通，形成一个覆盖所有顶点的树，并且总权重最小。

~~~matlab
a(1,2)=50; a(1,3)=60; a(2,4)=65; a(2,5)=40;
a(3,4)=52;a(3,7)=45; a(4,5)=50; a(4,6)=30;
a(4,7)=42; a(5,6)=70; 
[i,j,b]=find(a);
data=[i';j';b'];index=data(1:2,:);
loop=max(size(a))-1;
result=[];
while length(result)<loop
 temp=min(data(3,:));
 flag=find(data(3,:)==temp);
 flag=flag(1);
 v1=index(1,flag);v2=index(2,flag);
 if v1~=v2
 result=[result,data(:,flag)];
 end
 index(find(index==v2))=v1;
 data(:,flag)=[];
 index(:,flag)=[];
end
resul
~~~

